<html>
<body>
<canvas id="layer0" height="1200" width="1200" style="position:absolute;top:0px;left:0px;z-index:0;"></canvas>
<canvas id="layer1" height="1200" width="1200" style="position:absolute;top:0px;left:0px;z-index:1;opacity:0.3"></canvas>
<script>
(function(){
	var rad2deg=360.0/(2*Math.PI);
	var pi2=Math.PI/2;
	var elem1=document.getElementById("layer0");
	if (elem1 && elem1.getContext) {
		var ctx1 = elem1.getContext('2d');
		if (!ctx1) return;
	}

	var elem2=document.getElementById("layer1");
	if (elem2 && elem2.getContext) {
		var ctx2 = elem2.getContext('2d');
		if (!ctx2) return;
	}
	var ctx;
	function go_layer1(){
		ctx=ctx1;
	}

	function go_layer2(){
		ctx=ctx2;
	}

	var Point=function(x_,y_){
		this.x=x_;
		this.y=y_;
		return {
			x:this.x,
			y:this.y,
			paint:function(){
				point(this.x, this.y);
			},
			add_vector:function(v){
				return new Point(this.x+v.dx, this.y+v.dy);
			},
			get_vector:function(p0){
				return new Vector(this.x-p0.x, this.y-p0.y);
			}
		}
	}
	var Vector=function(dx_=1.0, dy_=0.0){
		this.dx=dx_;
		this.dy=dy_;
		return {
			dx:this.dx,
			dy:this.dy,
			get_cross_angle:function(v){
				return v.get_angle()-this.get_angle();
			},
			get_nearest_angle:function(v){
				return Math.acos((this.dx*v.dx+this.dy*v.dy)/(Math.sqrt(this.dx*this.dx+this.dy*this.dy)*Math.sqrt(v.dx*v.dx+v.dy*v.dy)));
			},
			get_angle:function(){
				var v1=new Vector().set_angle(0);
				var v2=new Vector().set_angle(pi2);
				var v3=new Vector().set_angle(Math.PI);
				var v4=new Vector().set_angle(Math.PI + pi2);

				var a1=v1.get_nearest_angle(this);
				var a2=v2.get_nearest_angle(this);
				var a3=v3.get_nearest_angle(this);
				var a4=v4.get_nearest_angle(this);

				// OX
				if (a1==0) return 0;
				// Квадрант I
				if (a3>pi2 && a4>pi2) return a1;
				// OY
				if (a2==0) return pi2;
				// Квадрант II
				if (a1>pi2 && a4>pi2) return pi2+a2;
				// -OX
				if (a3==0) return Math.PI;
				// Квадрант III
				if (a1>pi2 && a2>pi2) return Math.PI+a3;
				// -OY
				if (a4==0) return Math.PI+pi2;
				// Квадрант IV
				if (a3>pi2 && a2>pi2) return Math.PI+pi2+a4;
				return -1;
			},
			reverse:function(){
				return new Vector(-this.dx, -this.dy);
			},
			multi:function(k){
				return new Vector(this.dx*k, this.dy*k);
			},
			set_length:function(l){
				var l0=this.get_length();
				return new Vector(this.dx*l/l0, this.dy*l/l0);
			},
			paint_at:function(p0, pf=false){
				if (pf) p0.paint();
				line(p0.x, p0.y, p0.x+this.dx, p0.y+this.dy);

				var p1=p0.add_vector(this);
				var v1=this.reverse().set_length(0.5).add_angle(-17/rad2deg);
				var v2=this.reverse().set_length(0.5).add_angle(17/rad2deg);
				triangle(p1.x, p1.y, p1.x+v1.dx, p1.y+v1.dy, p1.x+v2.dx, p1.y+v2.dy);
			},
			get_length:function(){
				return Math.sqrt(this.dx*this.dx+this.dy*this.dy);
			},
			add_angle:function(a){
				var new_a=new Vector().get_cross_angle(this)+a;
				var l=this.get_length();
				return new Vector(Math.cos(new_a)*l, -Math.sin(new_a)*l);
			},
			set_angle:function(a){
				var l=this.get_length();
				return new Vector(Math.cos(a)*l, -Math.sin(a)*l);
			}
		}
	}

	var Circle=function(p0, r, d=1){
		this.center = new Point(p0.x, p0.y);
		this.radius = r;
		this.direction = d;
		return {
			center:this.center,
			radius:this.radius,
			direction:this.direction,
			paint:function(d=false){
				circle(this.center.x, this.center.y, this.radius);
				if (d) {
					arc(this.center.x, this.center.y, 0.5, -pi2/2+this.direction*pi2/2, 2.5*pi2+pi2/2*this.direction);
					var p = new Point(this.center.x, this.center.y-0.5);
					new Vector(this.direction,0).multi(0.3).paint_at(p);
				}
				return this;
			},
			paint_arc:function(a0, a1){
				arc(this.center.x, this.center.y, this.radius, a0, a1);
			},
			get_tangent_angle:function(p, kd=1){
				v2p=this.center.get_vector(p).reverse();
				l2p = v2p.get_length();
				return v2p.get_angle()+kd*Math.acos(this.radius/l2p);
			},
			get_angle_point:function(a){
				return this.center.add_vector(new Vector().set_angle(a).multi(this.radius));
			},
			get_tangent_with:function(c0, debug=false){
				var tmp_strokeStyle = ctx.strokeStyle;
				var tmp_fillStyle = ctx.fillStyle;
				ctx.strokeStyle="#999";
				ctx.fillStyle="#999";

				var c_, p_, tp_, tv_, s_;
				if (this.radius==c0.radius && this.direction == c0.direction){
					tv_ = this.center.get_vector(c0.center);
					if (debug) tv_.paint_at(c0.center);
					s_ = tv_.add_angle(-this.direction*pi2).set_length(this.radius);
					if (debug) s_.paint_at(this.center);
					var pp = {p0:null, p1:null};
					pp.p0 = this.center.add_vector(s_);
					pp.p1 = pp.p0.add_vector(tv_.reverse());
				} else if(this.radius>c0.radius && this.direction == c0.direction){
					c_=new Circle(this.center, this.radius-c0.radius, this.direction);
					if (debug) c_.paint();
					tp_ = c_.get_angle_point(c_.get_tangent_angle(c0.center, c_.direction));
					if (debug) tp_.paint();
					tv_ = tp_.get_vector(c0.center);
					if (debug) tv_.paint_at(c0.center);
					s_ = tp_.get_vector(this.center).set_length(this.radius);
					if (debug) s_.paint_at(this.center);
					var pp = {p0:null, p1:null};
					pp.p0 = this.center.add_vector(s_);
					pp.p1 = pp.p0.add_vector(tv_.reverse());
				} else if (this.radius<c0.radius && this.direction == c0.direction){
					c_=new Circle(c0.center, c0.radius-this.radius, c0.direction);
					if (debug) c_.paint();
					tp_ = c_.get_angle_point(c_.get_tangent_angle(this.center, -c_.direction));
					if (debug) tp_.paint();
					tv_ = tp_.get_vector(this.center);
					if (debug) tv_.paint_at(this.center);
					s_ = tp_.get_vector(c0.center).set_length(c0.radius);
					if (debug) s_.paint_at(c0.center);
					var pp = {p0:null, p1:null};
					pp.p1 = c0.center.add_vector(s_);
					pp.p0 = pp.p1.add_vector(tv_.reverse());
				} else if (this.radius>=c0.radius && this.direction != c0.direction){
					c_=new Circle(this.center, this.radius+c0.radius, this.direction);
					if (debug) c_.paint();
					tp_ = c_.get_angle_point(c_.get_tangent_angle(c0.center, c_.direction));
					if (debug) tp_.paint();
					tv_ = tp_.get_vector(c0.center);
					if (debug) tv_.paint_at(c0.center);
					s_ = tp_.get_vector(this.center).set_length(this.radius);
					if (debug) s_.paint_at(this.center);
					var pp = {p0:null, p1:null};
					pp.p0 = this.center.add_vector(s_);
					pp.p1 = pp.p0.add_vector(tv_.reverse());
				} else if (this.radius<c0.radius && this.direction != c0.direction){
					c_=new Circle(c0.center, c0.radius+this.radius, c0.direction);
					if (debug) c_.paint();
					tp_ = c_.get_angle_point(c_.get_tangent_angle(this.center, -c_.direction));
					if (debug) tp_.paint();
					tv_ = tp_.get_vector(this.center);
					if (debug) tv_.paint_at(this.center);
					s_ = tp_.get_vector(c0.center).set_length(c0.radius);
					if (debug) s_.paint_at(c0.center);
					var pp = {p0:null, p1:null};
					pp.p1 = c0.center.add_vector(s_);
					pp.p0 = pp.p1.add_vector(tv_.reverse());
				}


				ctx.strokeStyle = tmp_strokeStyle;
				ctx.fillStyle = tmp_fillStyle;

				return pp;
			}
		}
	}

	line=function(x0, y0, x1, y1){
		ctx.beginPath();
		moveTo(x0, y0);
		lineTo(x1, y1);
		ctx.stroke();
	}.bind(this);

	lineTo=function(x1, y1){
		ctx.lineTo(x1*this.zoom+0.5, y1*this.zoom+0.5);
	}.bind(this);

	moveTo=function(x0, y0){
		ctx.moveTo(x0*this.zoom+0.5, y0*this.zoom+0.5);
	}.bind(this);

	arc=function(x0, y0, r, a0, a1){
		ctx.beginPath();
		ctx.arc(x0*this.zoom+0.5, y0*this.zoom+0.5, r*zoom, a0, a1);
		ctx.stroke();
	}.bind(this)

	pie=function(x0, y0, r, a0, a1){
		ctx.beginPath();
		ctx.arc(x0*this.zoom+0.5, y0*this.zoom+0.5, r*zoom, a0, a1);
		lineTo(x0,y0);
		ctx.fill();
	}.bind(this)

	circle=function(x0, y0, r){
		arc(x0, y0, r, 0, 2*Math.PI);
	}.bind(this)

	point=function(x0, y0){
		ctx.beginPath();
		ctx.arc(x0*this.zoom+0.5, y0*this.zoom+0.5, 2.5, 0, 2*Math.PI);
		ctx.fill();
	}.bind(this)

	triangle=function(x0, y0, x1, y1, x2, y2){
		ctx.beginPath();
		moveTo(x0, y0);
		lineTo(x1, y1);
		lineTo(x2, y2);
		ctx.fill();
	}.bind(this)


	zoom=25;

	go_layer1();

	ctx.lineWidth = 1;

	// Рамка
	ctx.strokeStyle = '#555';
	ctx.strokeRect(0.5, 0.5, ctx.canvas.clientWidth-0.5, ctx.canvas.clientHeight-0.5);

	// Сетка
	ctx.strokeStyle = '#ccc';

	for(var i=0;i<=50;i++){
		line(i,0,i,50);
		line(0,i,50,i);
	}

	ctx.strokeStyle = '#000';

	var rollers=[
			new Circle(new Point(10, 10), 1, 1)
		,	new Circle(new Point(40, 10), 2, 1)
		,	new Circle(new Point(30, 15), 3, -1)
		,	new Circle(new Point(30, 25), 2, 1)
	]

	var path=[];

	for(i=0;i<=rollers.length-1;i++){
		rollers[i].center.paint();
		rollers[i].paint(true);

		var next_roller = rollers[(i+1) % rollers.length];
		pp = rollers[i].get_tangent_with(next_roller);
		pp.p0.paint();
		pp.p1.paint();
		pp.p1.get_vector(pp.p0).paint_at(pp.p0);

		path.push({
			type:"line",
			start:pp.p0,
			end:pp.p1,
			vector:pp.p1.get_vector(pp.p0)
		});

		path.push({
			type:"arc",
			start:pp.p1,
			end:null,
			circle:next_roller,
			start_angle:pp.p1.get_vector(next_roller.center).get_angle(),
			end_angle:null
		});

		if(path.length>2 && path[path.length-3].type=="arc"){
			path[path.length-3].end = pp.p0;
			path[path.length-3].end_angle = pp.p0.get_vector(path[path.length-3].circle.center).get_angle();
		}
	}
	if(path.length>2 && path[path.length-1].type=="arc" && path[0].type=="line"){
		path[path.length-1].end = path[0].start;
		path[path.length-1].end_angle = path[0].start.get_vector(path[path.length-1].circle.center).get_angle();
	}
	console.log(path);

	go_layer2();

	ctx.strokeStyle = '#0f0';
	ctx.fillStyle = '#5f5';
	ctx.lineWidth = 3;


	for(i=0;i<path.length;i++){
		if (path[i].type=='line') line(path[i].start.x, path[i].start.y, path[i].end.x, path[i].end.y);
		if (path[i].type=='arc'){
			//arc(path[i].circle.center.x, path[i].circle.center.y, path[i].circle.radius, -path[i].start_angle, -path[i].end_angle);
			pie(
				path[i].circle.center.x, 
				path[i].circle.center.y, 
				path[i].circle.radius, 
				path[i].circle.direction==1?-path[i].start_angle:-path[i].end_angle,
				path[i].circle.direction==1?-path[i].end_angle:-path[i].start_angle
			);
		}
	}

})()
</script>
</body>
</html>
